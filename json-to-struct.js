$(document).ready(function(){
  var go =""

  //KeyMap is used as map instead of array for future use.
  var keyMap = new Map();
  var tab = 0
//  var data ='{"Header": "headerdata", "body":{"body1": "body1data", "body2": {"la": {"fa":"tuku"}}}, "tail":{"tick": "tock"}}'
  //var data ='{"header":[{"h1":"value", "data2": "value"},{"h1":"value","h2":"value"}]}'
  var data ='{"header":[{"h1":"h1"},{"h1":"lol","h2":"h2","h3":"ratar"}],"body":{"b1":"value","b2":"value"}}'
  $("#convertData").click(function(){
      convertToStruct("",JSON.parse(data));
      var mapIter = keyMap.values();
      //var mapData = new Map();
      finalData =[]
      console.log("data in keyMap", keyMap);
      for (var i=0;i<keyMap.size; i++){
        finalData[i]=mapIter.next().value;
      }
      console.log("finalData", finalData);
      for(var j=finalData.length-1; j>=0;j--){
        console.log("inside finalData");
        appendString(finalData[j])
      }
      console.log("Final data ::::", go);
  });

function convertToStruct(keyName, objectData){
  if(keyName == ""){
    keyName = "AutoGenerated"
  }

  
  console.log("keyName",keyName)
  var str = JSON.stringify(objectData);
  console.log("data received",str)
  var nestedGo ="";

  var jsonObject;
  try {
      jsonObject = JSON.parse(str);
  } catch (e) {
      console.log("invalid json format");
      return;
  }
  nestedGo += "type "+firstLetterUppercase(keyName)+" struct {\n"

  for(var k in jsonObject){
    if( goType(jsonObject[k]) === "struct"){
      convertToStruct(firstLetterUppercase(k), jsonObject[k] )
    }
    if(goType(jsonObject[k]) === "slice"){
      nestedGo += "\t"+firstLetterUppercase(k)+" []struct"+' `json:"'+k+'"`\n'
      parseData(k,jsonObject[k])
    }else{
        nestedGo += "\t"+firstLetterUppercase(k)+" "+goType(jsonObject[k])+' `json:"'+k+'"`\n'
    }

  }
  nestedGo +="}\n"
  console.log("nestedGo",nestedGo);
  keyMap.set(keyName, nestedGo)

}



function goType(val){
  switch (typeof val)
		{
			case "string":
					return "string";
			case "number":
				if (val % 1 === 0)
				{
						return "int";
				}
				else
					return "float64";
			case "boolean":
				return "bool";
			case "object":
        console.log("inside object");
				if (Array.isArray(val))
					return "slice";
				return "struct";
			default:
				return "notFound";
		}

}


function appendString(str){
  console.log("data to append", str);
  go += str;

}

function firstLetterUppercase(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
}


function parseData(keyName,scope){
  var mapData = new Map();
  //mapData["name"]="my name";
  if (Array.isArray(scope)){
    console.log("recieved data in parseData()", scope);
      var scopeLength = scope.length;
      var nestedGo =""
      nestedGo += "type "+firstLetterUppercase(keyName)+" struct {\n"
      for (var i = 0; i < scopeLength; i++){
        var str = JSON.stringify(scope[i]);
        var jsonObject = JSON.parse(str);

        console.log("jsonObject in parseData()", jsonObject);
        for(var k in jsonObject){
          if(!mapData.hasOwnProperty(k)){
            mapData[k] = goType(jsonObject[k])
          }
        }

      }
      for (var k in mapData){
          nestedGo += "\t"+firstLetterUppercase(k)+" "+mapData[k]+' `json:"'+k+'"`\n'
      }
      nestedGo += "}\n"
      console.log("nestedGo yo::::", nestedGo);
      keyMap.set(keyName, nestedGo)
  }
}
});


//TODO add omitempty in json where it is necessary
